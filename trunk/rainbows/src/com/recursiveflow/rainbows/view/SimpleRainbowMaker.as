package com.recursiveflow.rainbows.view {    import flash.geom.Rectangle;        import flash.display.Shape;    import flash.display.Sprite;    import flash.filters.BlurFilter;    import flash.geom.Point;        /**     * Draws a series of rainbow coloured concentric circles onto a canvas.     *      * Uses a scroll rectangle to constrain the viewable area and enhance efficiency.     *      * @author Alastair Dant     */    public class SimpleRainbowMaker extends Sprite     {        internal static const COLOURS : Array = [0xdc1400,0xdc8c00,0xdcdc00,0x00dc3c,0x008cdc,0x0050dc,0x6400dc,0x000000];        internal static const ORIGIN : Point = new Point(0,0);        internal static const ARGB_WHITE : uint = 0xFFFFFFFF;                private var canvas : Shape;        private var background : Shape;        private var maxHeight : Number;        private var lastPeak : Number;        private var blur : BlurFilter;        public function SimpleRainbowMaker(w:Number, h:Number)        {        	this.canvas = new Shape();        	this.background = createBox(w, h, 0xFFFFFF);            this.maxHeight = h * 0.75;            this.lastPeak = 0;                        this.blur = new BlurFilter(5,5);            this.filters = [ blur ];                          addChild(background);                      addChild(canvas);                        this.cacheAsBitmap = true;            this.scrollRect = new Rectangle(0,0,w,h);        }        public function redraw(peak:Number, origin:Point, interpolate:Boolean = true) : void        {        	if (interpolate)        	{ 		    	peak = (peak < 0.3) ? lastPeak * 0.8 : (peak + lastPeak) / 2;        	}        				drawRainbows(peak,origin);						blur.blurX = blur.blurY = 50 * peak;			        	        }        private function drawRainbows(peak : Number, origin:Point) : void        {        	var colour:Number, size:Number;        	        	canvas.graphics.clear();        	        	for (var i : Number = COLOURS.length - 2; i >= 0; i--)        	{        		colour = COLOURS[i];        		size = 50 * peak;        		        		canvas.graphics.lineStyle(size, colour, peak);        		canvas.graphics.drawCircle(origin.x, origin.y, (maxHeight*peak) + 50 + (size * (COLOURS.length-i) * 0.95));        	}           	        	lastPeak = peak;     	        }                private static function createBox(w:Number, h:Number, c:Number) : Shape        {        	var box : Shape = new Shape();        	        	box.graphics.beginFill(c,1);        	box.graphics.drawRect(0, 0, w, h);        	box.graphics.endFill();        	        	return box;        }    }}