package com.recursiveflow.rainbows.view {    import flash.display.Shape;    import flash.display.Sprite;    import flash.filters.BlurFilter;    import flash.filters.GlowFilter;    import flash.geom.Point;    import flash.media.SoundMixer;    import flash.utils.ByteArray;        /**     * Analyzes the spectrum of currently playing sounds, then depicts the result using a series of      * rainbow coloured particles arranged along polar-plotted lines emenating from an arbitrary origin.     *      * The origin moves around subject to random forces, but is always drawn back towards center stage     * by a pair of springs.     *      * Blur and glow filter effects are applied dynamically according to the current peak amplitude.     *      * @author Alastair Dant     */    public class RadialVisualizer extends Sprite     {        private var xMid : Number, xMax : Number, yMid : Number, yMax : Number;        private var particles : Array;        private var angles : Array;        private var endPoints : Array;        private var origin : Point;        private var peak : Number;        private var bytes : ByteArray = new ByteArray();        private var vx : Number = 0;        private var vy : Number = 0;                private var blur : BlurFilter;        private var glow : GlowFilter;        private static const WAVE_COUNT : Number = 32;        private static const I_WAVE_COUNT : Number = 1 / WAVE_COUNT;        private static const PARTICLES_PER_WAVE : Number = RainbowMaker.COLOURS.length;        private static const I_PARTICLES_PER_WAVE : Number = 1 / PARTICLES_PER_WAVE;        private static const PARTICLE_SIZE : Number = 7;        private static const MAX_BYTE : Number = 256;        private static const BYTES_PER_WAVE : Number = Math.ceil(MAX_BYTE/WAVE_COUNT);        private static const MAX_BLUR : Number = 10;        private static const MAX_GLOW : Number = 20;        private static const SPRING_FACTOR : Number = 0.01;        private static const FRICTION_FACTOR : Number = 0.85;        private static const WALK : Number = 3;        public function RadialVisualizer(xMid : Number, xMax : Number, yMid : Number, yMax : Number)        {            this.xMid = xMid;            this.xMax = xMax;                                   this.yMid = yMid;            this.yMax = yMax;			            this.endPoints = new Array(WAVE_COUNT);        	            this.blur = new BlurFilter();            this.glow = new GlowFilter();        	        	setupGFX();        }                    private function setupGFX() : void        {            var particle:Shape;            var waveParticles:Array;            var opacity:Number;            var scale:Number;                        this.reset();                        this.particles = [WAVE_COUNT];            this.angles = [WAVE_COUNT];            this.filters = [blur, glow];                        for(var c:Number = 0; c < PARTICLES_PER_WAVE; c++)            {            	addChildAt(new Sprite(),c);            }                        for (var wave : Number = 0; wave < WAVE_COUNT; wave++)             {            	scale = 1;            	waveParticles = [];            	            	while(waveParticles.length < PARTICLES_PER_WAVE)            	{            		opacity = 1 - (waveParticles.length * I_PARTICLES_PER_WAVE * 0.5);										particle = new Particle(PARTICLE_SIZE , RainbowMaker.COLOURS[waveParticles.length] , opacity);            			            		            	particle.x = xMid;	            	particle.y = yMid;		            		            	particle.scaleX = particle.scaleY = scale;	            	            		(getChildAt(waveParticles.length) as Sprite).addChild(particle);	            	waveParticles.unshift(particle);	            	            		scale *= 0.9;             		            	}            	            	angles[wave] = (2 * Math.PI) * (wave * I_WAVE_COUNT);            	particles[wave] = waveParticles;            }        }        public function destroy() : void        {        	var waveParticles:Array;        	        	while(particles.length > 0)         	{        		waveParticles = particles.pop(); 	        	while(waveParticles.length > 0) { waveParticles.pop(); }        	}        	        	particles = null;        }                /**         * Draws lines from the ends of all axes to origin         */        public function drawBoundary() : void        {        	graphics.clear();        	graphics.lineStyle(1, 0, 0.2);        	        	for each (var p : Point in endPoints)         	{        		graphics.moveTo(xMid, yMid);        		graphics.lineTo(origin.x + p.x, origin.y + p.y);        	}        }		public function update(isDrawing : Boolean) : void		{			updateOrigin(isDrawing);			plotSpectrum(isDrawing);			        }                private function updateOrigin(isDrawing : Boolean) : void        {			if (isDrawing) 			{				origin.x = mouseX;				origin.y = mouseY;			}				else			{				origin.x += ((2*WALK*Math.random())-WALK);				origin.y += ((2*WALK*Math.random())-WALK);			}						vx += (xMid - origin.x) * SPRING_FACTOR;			vy += (yMid - origin.y) * SPRING_FACTOR;			vx *= FRICTION_FACTOR;			vy *= FRICTION_FACTOR;			origin.x += vx;			origin.y += vy;        }        private function plotSpectrum(isDrawing : Boolean) : void        {			var waveParticles:Array, particle : Particle;            var byte:Number, wave:Number = WAVE_COUNT, p:Number = 0;			var amplitude:Number = 0, bytesRead:Number = 0, stretch:Number = 0;			var location:Point;			            peak = 0;						            SoundMixer.computeSpectrum(bytes, false, 0);	// Compute the spectrum as a raw wave at 44.1 KHz						for (byte = MAX_BYTE - 1; byte >= 0; byte--) 			{				amplitude += bytes.readFloat();				bytesRead++;								if (byte % BYTES_PER_WAVE == 0)				{					waveParticles = particles[--wave] as Array;										amplitude /= bytesRead;					peak = Math.max(Math.abs(amplitude),peak);					stretch = amplitude * yMax * I_PARTICLES_PER_WAVE;										                    for (p = 0; p < PARTICLES_PER_WAVE; p++)					{	                    particle = waveParticles[p] as Particle; 	                    location = Point.polar(p * stretch, angles[wave]);	                     						particle.x = origin.x + location.x;//(origin.x + location.x + particle.x) * 0.5;						particle.y = origin.y + location.y;//(origin.y + location.y + particle.y) * 0.5;					}										amplitude = 0;					bytesRead = 0;										endPoints[wave] = location;				}			}        							(isDrawing) ? drawBoundary() : graphics.clear();        }                                public function updateFilters() : void        {      		glow.strength = MAX_GLOW * peak;	  	        	blur.blurY = blur.blurX = MAX_BLUR * peak;        }                public function getPeak() : Number        {            return peak;        }                public function getOrigin() : Point        {            return origin;        }                public function reset() : void        {        	this.peak = 0;            this.origin = new Point(xMid, yMid);        }    }}