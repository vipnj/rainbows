package com.recursiveflow.rainbows.view {    import flash.display.Bitmap;    import flash.display.BitmapData;    import flash.display.Shape;    import flash.filters.BlurFilter;    import flash.geom.Point;    import flash.geom.Rectangle;            /**     * Draws a series of rainbow coloured concentric circles onto a Bitmap canvas with constrained proportions,     * then slices the image into four quadrants and rearranges their positions to create a kaleidoscopic effect.     *      * @author Alastair Dant     */    public class RainbowMaker extends Bitmap     {        public static const COLOURS : Array = [0xdc1400,0xFF8000,0xFFE600,0x00dc3c,0x008cdc,0x0050dc,0x6400dc,0x4B0082];                internal static const ORIGIN : Point = new Point(0,0);        internal static const ARGB_WHITE : uint = 0xFFFFFFFF;                private var canvas : Shape;        private var maxHeight : Number;        private var lastPeak : Number;        private var buffer : BitmapData;        private var blur : BlurFilter;                private var tlq : Rectangle, trq : Rectangle, blq : Rectangle, brq : Rectangle;        private var middle : Point, midTop : Point, midLeft : Point;        public function RainbowMaker(width:Number, height:Number)        {        	super(new BitmapData(width,height,false,ARGB_WHITE),"auto",true);        	            this.canvas = createBox(width, height, 0xFFFFFF);            this.buffer = bitmapData.clone();            this.maxHeight = height * 0.75;            this.lastPeak = 0;                        this.tlq = new Rectangle(0      ,0       ,width/2,height/2);            this.trq = new Rectangle(width/2,0       ,width/2,height/2);            this.blq = new Rectangle(0      ,height/2,width/2,height/2);            this.brq = new Rectangle(width/2,height/2,width/2,height/2);                        this.middle  = new Point(width/2,height/2);             this.midTop  = new Point(width/2,0);            this.midLeft = new Point(0,height/2);                        this.blur = new BlurFilter(5,5);            this.filters = [ blur ];                    }        public function redraw(peak:Number) : void        {        	peak = (peak < 0.3) ? lastPeak * 0.8 : (peak + lastPeak) / 2;						drawRainbows(peak);			copyCanvasToBuffer();			translateBufferToCanvas();						blur.blurX = blur.blurY = 10 * peak;			        	        }        private function drawRainbows(peak : Number) : void        {        	var colour:Number, size:Number;        	        	canvas.graphics.clear();        	        	for (var i : Number = COLOURS.length - 2; i >= 0; i--)        	{        		colour = COLOURS[i];        		size = 50 * peak;        		        		canvas.graphics.lineStyle(size, colour, peak);        		canvas.graphics.drawCircle(middle.x, middle.y, (maxHeight*peak) + 50 + (size * (COLOURS.length-i) * 0.95));        	}           	        	lastPeak = peak;     	        }                private function copyCanvasToBuffer() : void        {        	this.buffer.lock();        	this.buffer.fillRect(bitmapData.rect, ARGB_WHITE);            this.buffer.draw(canvas);        	this.buffer.unlock();        }                private function translateBufferToCanvas() : void        {        	this.bitmapData.lock();        	this.bitmapData.copyPixels(buffer, brq, ORIGIN);        	this.bitmapData.copyPixels(buffer, blq, midTop);        	this.bitmapData.copyPixels(buffer, trq, midLeft);        	this.bitmapData.copyPixels(buffer, tlq, middle);        	this.bitmapData.unlock();        }        private static function createBox(w:Number, h:Number, c:Number) : Shape        {        	var box : Shape = new Shape();        	        	box.graphics.beginFill(c,1);        	box.graphics.drawRect(0, 0, w, h);        	box.graphics.endFill();        	        	return box;        }    }}